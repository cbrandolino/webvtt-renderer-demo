{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","lib/VTTParser/parseOptions.ts","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","lib/VTTParser/ParsingError.ts","lib/VTTParser/Settings.ts","lib/shared/parseTimestamp.ts","lib/VTTParser/parseCue.ts","lib/shared/XCue.ts","lib/types.ts","lib/VTTParser/parseRegion.ts","lib/VTTParser/index.ts","lib/VTTParser/VTTParser.ts"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","parseOptions","input","callback","keyValueDelim","groupDelim","groups","split","kv","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_inherits","subClass","superClass","create","constructor","value","_getPrototypeOf","getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_typeof","obj","Symbol","iterator","_possibleConstructorReturn","self","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","this","arguments","apply","Parent","args","Class","a","push","Function","bind","_cache","Map","undefined","fn","indexOf","has","get","set","Wrapper","ParsingError","errorData","message","name","code","Error","Errors","BadSignature","BadTimeStamp","Settings","values","k","v","dflt","defaultKey","defaultValue","n","test","parseInt","match","vFloat","parseFloat","parseTimeStamp","computeSeconds","h","m","s","f","matches","map","x","replace","parseCue","cue","regionList","oInput","consumeTimeStamp","ts","skipWhitespace","startTime","substr","endTime","settings","id","region","alt","vals","vals0","integer","percent","console","log","vertical","line","lineAlign","snapToLines","size","align","position","positionAlign","start","left","center","end","right","consumeCueSettings","XCue","json","cueKeys","forEach","VTTCue","parseRegion","onRegion","xy","anchor","VTTRegion","width","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","VTTParser","onError","onCue","onFlush","decoder","_state","_buffer","_decoder","_cue","_regionList","TextDecoder","data","collectNextLine","buffer","pos","decode","stream","alreadyCollectedLine","toJSON","reportOrThrowError","hasSubstring","text","parse"],"mappings":"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","file":"static/js/main.d6737c8d.chunk.js","sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","  // Helper function to parse input into groups separated by 'groupDelim', and\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\n  function parseOptions(\n    input:string,\n    callback:(k: string, v: string) => void,\n    keyValueDelim:RegExp,\n    groupDelim?:RegExp\n  ) {\n    var groups = groupDelim ? input.split(groupDelim) : [input];\n    for (var i in groups) {\n      if (typeof groups[i] !== \"string\") {\n        continue;\n      }\n      var kv = groups[i].split(keyValueDelim);\n      if (kv.length !== 2) {\n        continue;\n      }\n      var k = kv[0];\n      var v = kv[1];\n      callback(k, v);\n    }\n  }\n\n  export default parseOptions;","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n\n\ninterface IParsingError {\n  name: string,\n  code?: number,\n  message?: string,\n}\n\n// See ParsingError.Errors below for acceptable errors.\nclass ParsingError extends Error implements IParsingError {\n  name = 'ParsingError';\n  code;\n  message = '';\n\n  constructor(errorData:{ code: number, message?: string}, message?: string) {\n    super(message || errorData.message);\n    this.code = errorData.code\n  }\n\n  static Errors = {\n    BadSignature: {\n      code: 0,\n      message: \"Malformed WebVTT signature.\"\n    },\n    BadTimeStamp: {\n      code: 1,\n      message: \"Malformed time stamp.\"\n    }\n  }\n};\n\nexport default ParsingError;\n","import { CuePropValue } from '../types';\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\ninterface ISettings {\n  values: Object;\n  set: (k: string, v: unknown) => void;\n}\n\ntype Defaults = Record<string, CuePropValue>|CuePropValue;\n\nclass Settings implements ISettings {\n  values = Object.create(null);\n\n  set(k:string, v:unknown) {\n    if (!this.get(k) && v !== \"\") {\n      this.values[k] = v;\n    }\n  }\n\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k:string, dflt?:Defaults, defaultKey?:string) {\n    const defaultValue = (defaultKey && (dflt instanceof Object)) ? dflt[defaultKey] : dflt;\n    return this.has(k) ? this.values[k] : defaultValue;\n  }\n\n  // Check whether we have a value for a key.\n  has(k:string) {\n    return k in this.values;\n  }\n\n  // Accept a setting if its one of the given alternatives.\n  alt(k:string, v:unknown, a:Array<unknown>) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n\n  // Accept a setting if its a valid (signed) integer.\n  integer(k:string, v:string) {\n    if (/^-?\\d+$/.test(v)) { // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n\n  // Accept a setting if its a valid percentage.\n  percent(k:string, v:string) {\n    if ((v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/))) {\n      const vFloat = parseFloat(v);\n      if (vFloat >= 0 && vFloat <= 100) {\n        this.set(k, vFloat);\n        return true;\n      }\n    }\n    return false;\n  }\n  \n}\n\nexport default Settings;","function parseTimeStamp(input:string):number|null {\n\n  function computeSeconds(h:number, m:number, s:number, f:number) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var matches = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!matches) {\n    return null;\n  }\n\n  const m = matches.map(x => parseInt(x.replace(':', '')))\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3], m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0,  m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\nexport default parseTimeStamp;\n","import ParsingError from \"./ParsingError\";\nimport parseOptions from \"./parseOptions\";\nimport Settings from \"./Settings\";\nimport parseTimeStamp from \"../shared/parseTimestamp\";\nimport { JsonCue } from \"../types\";\n\nfunction parseCue(input:string, cue:JsonCue, regionList?:Array<{region: VTTRegion, id: string}>) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  \n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                            \"Malformed timestamp: \" + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input:string, cue:JsonCue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n      case \"region\":\n        // Find the last region we parsed with the same region id.\n        if (regionList) {\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n        }\n        break;\n      case \"vertical\":\n        settings.alt(k, v, [\"rl\", \"lr\"]);\n        break;\n      case \"line\":\n        var vals = v.split(\",\"),\n            vals0 = vals[0];\n        settings.integer(k, vals0);\n        settings.percent(k, vals0) ?? settings.set(\"snapToLines\", false);\n        settings.alt(k, vals0, [\"auto\"]);\n        if (vals.length === 2) {\n          settings.alt(\"lineAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"position\":\n        vals = v.split(\",\");\n        settings.percent(k, vals[0]);\n        if (vals.length === 2) {\n          settings.alt(\"positionAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n        }\n        break;\n      case \"size\":\n        settings.percent(k, v);\n        break;\n      case \"align\":\n        settings.alt(k, v, [\"start\", \"middle\", \"end\", \"left\", \"right\"]);\n        break;\n      }\n    }, /:/, /\\s/);\n\n    console.log('parsing cue:', cue)\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get(\"region\", null);\n    cue.vertical = settings.get(\"vertical\", \"\");\n    cue.line = settings.get(\"line\", \"auto\");\n    cue.lineAlign = settings.get(\"lineAlign\", \"center\");\n    cue.snapToLines = settings.get(\"snapToLines\", true);\n    cue.size = settings.get(\"size\", 100);\n    cue.align = settings.get(\"align\", \"middle\");\n    cue.position = settings.get(\"position\", \"auto\");\n    cue.positionAlign = settings.get(\"positionAlign\", {\n      start: \"start\",\n      left: \"start\",\n      center: \"center\",\n      end: \"end\",\n      right: \"end\"\n    }, cue.align);\n\n    console.log('defaults applied!', cue)\n  }\n\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, \"\");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp();   // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== \"-->\") {     // (3) next characters must match \"-->\"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                           \"Malformed time stamp (time stamps must be separated by '-->'): \" +\n                           oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp();     // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nexport default parseCue;","import { JsonCue, cueKeys, CueKeys } from \"../types\";\n\n/**\n * Extends the native VTTCue to add a {@link XCue.toJSON | toJSON} method.\n * \n * A shim is available at {}\n */\nclass XCue extends VTTCue {\n\n  /**\n   * @returns A {@link JsonCue} object for the current cue.\n   */\n  public toJSON():JsonCue {\n    const json:Record<string, unknown> = {};\n    cueKeys.forEach((key:CueKeys) => { \n      json[key] = this[key]\n    });\n    return json as JsonCue;\n  }\n\n  public set<K extends CueKeys>(key: K, value: this[K]): void {\n    this[key] = value;\n  }\n}\n\nexport default XCue;","import XCue from \"./shared/XCue\";\nexport type { IVTTParser, ParserCommon, IParserOptions } from \"./VTTParser/VTTParser\";\n\nexport const cueKeys = ['align', 'endTime', 'id', 'line', 'lineAlign', \n    'pauseOnExit', 'position', 'positionAlign', 'startTime', 'region', 'size',\n    'snapToLines', 'startTime', 'text', 'vertical'] as const;\n\nexport type CueKeys = typeof cueKeys[number]\nexport type JsonCue = Pick<XCue, CueKeys>;\nexport type CuePropValue = string | number | null | boolean;\nexport { XCue };\n","import parseOptions from \"./parseOptions\";\nimport Settings from \"./Settings\";\n\nexport interface IParseRegion {\n  /** The region you plan to add */\n  input:string,\n  /** The array of regions with the respective ids; will be modified by adding the new one */\n  regionList:Array<{ id: string, region: VTTRegion }>,\n  /** Callback to execute when a the region is parsed */\n  onRegion?: (region: VTTRegion) => void,\n}\n\nfunction parseRegion({ input, regionList, onRegion }:IParseRegion) {\n  var settings = new Settings();\n\n  parseOptions(input, function (k:string, v:string) {\n    switch (k) {\n    case \"id\":\n      settings.set(k, v);\n      break;\n    case \"width\":\n      settings.percent(k, v);\n      break;\n    case \"lines\":\n      settings.integer(k, v);\n      break;\n    case \"regionanchor\":\n    case \"viewportanchor\":\n      var xy = v.split(',');\n      if (xy.length !== 2) {\n        break;\n      }\n      // We have to make sure both x and y parse, so use a temporary\n      // settings object here.\n      var anchor = new Settings();\n      anchor.percent(\"x\", xy[0]);\n      anchor.percent(\"y\", xy[1]);\n      if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n        break;\n      }\n      settings.set(k + \"X\", anchor.get(\"x\"));\n      settings.set(k + \"Y\", anchor.get(\"y\"));\n      break;\n    case \"scroll\":\n      settings.alt(k, v, [\"up\"]);\n      break;\n    }\n  }, /=/, /\\s/);\n\n  // Create the region, using default values for any values that were not\n  // specified.\n  if (settings.has(\"id\")) {\n    var region = new VTTRegion();\n    region.width = settings.get(\"width\", 100);\n    region.lines = settings.get(\"lines\", 3);\n    region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n    region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n    region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n    region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n    region.scroll = settings.get(\"scroll\", \"\");\n    // Register the region.\n    onRegion && onRegion(region);\n    // Remember the VTTRegion for later in case we parse any VTTCues that\n    // reference it.\n    regionList.push({\n      id: settings.get(\"id\"),\n      region: region\n    });\n  }\n};\n\nexport default parseRegion;","import VTTParser from './VTTParser';\nimport parseRegion from './parseRegion';\n\nexport { parseRegion };\nexport default VTTParser;","import parseOptions from './parseOptions';\nimport ParsingError from './ParsingError';\nimport parseCue from './parseCue';\nimport { XCue, JsonCue } from '../types';\nimport { IParseRegion } from './parseRegion';\n\nexport type ParserCommon = {\n  onError?: (e:Error) => void;\n  onRegion?: (region:VTTRegion) => void;\n  onCue?: (cue:JsonCue) => void;\n  onFlush?: () => void;\n  parseRegion?: (regionProps:IParseRegion) => void;\n}\n\nexport interface IParserOptions extends ParserCommon {\n  decoder?: TextDecoder\n};\n\nexport interface IVTTParser extends ParserCommon {\n\n  parse: (data?:BufferSource) => IVTTParser,\n\n}\n\ntype ParserState = \"INITIAL\" | \"HEADER\" | \"NOTE\" | \"ID\" | \"CUE\" | \"BADCUE\" | \"CUETEXT\" | \"BADWEBVTT\";\n\n/**\n * The main parser class.\n * \n * {@link IVTTParser}\n */\nclass VTTParser implements IVTTParser {\n  onError;\n  onRegion;\n  onCue;\n  onFlush;\n  parseRegion?:(regionProps:IParseRegion) => void;\n\n  private _state:ParserState = \"INITIAL\";\n  private _buffer:string = \"\";\n  private _decoder:TextDecoder;\n  private _cue:JsonCue|null;\n  private _regionList:Array<{ id:string, region: VTTRegion}> = [];\n\n  /**\n   * \n   * @param settings\n   */\n  constructor({ onError, onRegion, onCue, onFlush, parseRegion, decoder }:IParserOptions){\n    this.onError = onError;\n    this.onRegion = onRegion;\n    this.onCue = onCue;\n    this.onFlush = onFlush;\n    this._cue = null;\n    this.parseRegion = parseRegion;\n    this._decoder = decoder || new TextDecoder(\"utf-8\");\n  }\n\n  private reportOrThrowError(e:Error|unknown) {\n    if (e instanceof ParsingError) {\n      this.onError && this.onError(e);\n    } else {\n      throw e;\n    }\n  }\n\n  public parse(data?:BufferSource|string) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self._buffer += (typeof data === 'string') ?\n         data:\n         self._decoder.decode(data, {stream: true});\n    }\n\n    function collectNextLine() {\n      var buffer = self._buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self._buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input:string) {\n      parseOptions(input, function (k, v) {\n        switch (k) {\n        case \"Region\":\n          // 3.3 WebVTT region metadata header syntax\n          self.parseRegion && self.parseRegion({\n            input: v,\n            regionList: self._regionList,\n            onRegion: self.onRegion\n          });\n          break;\n        }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (self._state === \"INITIAL\") {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self._buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self._state = \"HEADER\";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self._buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self._buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self._state) {\n        case \"HEADER\":\n          // 13-18 - Allow a header (metadata) under the WEBVTT line.\n          if (/:/.test(line)) {\n            parseHeader(line);\n          } else if (!line) {\n            // An empty line terminates the header and starts the body (cues).\n            self._state = \"ID\";\n          }\n          continue;\n        case \"NOTE\":\n          // Ignore NOTE blocks.\n          if (!line) {\n            self._state = \"ID\";\n          }\n          continue;\n        // @ts-ignore-line\n        case \"ID\":\n          // Check for the start of NOTE blocks.\n          if (/^NOTE($|[ \\t])/.test(line)) {\n            self._state = \"NOTE\";\n            break;\n          }\n          // 19-29 - Allow any number of line terminators, then initialize new cue values.\n          if (!line) {\n            continue;\n          }\n          self._cue = new XCue(0, 0, \"\").toJSON();\n          self._state = \"CUE\";\n          // 30-39 - Check if self line contains an optional identifier or timing data.\n          if (line.indexOf(\"-->\") === -1) {\n            self._cue.id = line;\n            continue;\n          }\n          // Process line as start of a cue.\n          /*falls through*/\n        case \"CUE\":\n          // 40 - Collect cue timings and settings.\n          try {\n            parseCue(line, self._cue!, self._regionList);\n          } catch (e:unknown) {\n            self.reportOrThrowError(e);\n            // In case of an error ignore rest of the cue.\n            self._cue = null;\n            self._state = \"BADCUE\";\n            continue;\n          }\n          self._state = \"CUETEXT\";\n          continue;\n        case \"CUETEXT\":\n          var hasSubstring = line.indexOf(\"-->\") !== -1;\n          // 34 - If we have an empty line then report the cue.\n          // 35 - If we have the special substring '-->' then report the cue,\n          // but do not collect the line as we need to process the current\n          // one as a new cue.\n          if (!line || (hasSubstring && (alreadyCollectedLine = true))) {\n            // We are done parsing self cue.\n            self.onCue && self._cue && self.onCue(self._cue);\n            self._cue = null;\n            self._state = \"ID\";\n            continue;\n          }\n          if (self._cue!.text) {\n            self._cue!.text += \"\\n\";\n          }\n          self._cue!.text += line;\n          continue;\n        case \"BADCUE\": // BADCUE\n          // 54-62 - Collect and discard the remaining cue.\n          if (!line) {\n            self._state = \"ID\";\n          }\n          continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self._state === \"CUETEXT\" && self._cue && self.onCue) {\n        self.onCue(self._cue as XCue);\n      }\n      self._cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self._state = self._state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  }\n\n  flush() {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self._buffer += self._decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self._cue || self._state === \"HEADER\") {\n        self._buffer += \"\\n\\n\";\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self._state === \"INITIAL\") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch(e) {\n      self.reportOrThrowError(e);\n    }\n    self.onFlush && self.onFlush();\n    return this;\n  }\n}\n\nexport default VTTParser;"],"sourceRoot":""}